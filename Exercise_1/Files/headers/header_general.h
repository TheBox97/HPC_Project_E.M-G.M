#ifndef HEADER_IMAGE
#define HEADER_IMAGE
#include <stdlib.h>
#include<stdio.h>




typedef enum { false, true } bool;

void write_pgm_image( void *image, int xsize,int ysize, const char *image_name)
{
const int maxval=255;
FILE* image_file;
image_file=fopen(image_name,"w");// Apro un file per scriverci
fprintf(image_file, "P5\n#generated by\n#Enrico Malcapi\n%d %d\n%d\n", ysize, xsize, maxval);// Scrivo nel file l'header
fwrite(image,1,xsize*ysize,image_file);//Scrivo la matrice che rappresenta l'immagine in una riga
fclose(image_file);
};


void* read_pgm_image(int* xsize,int*ysize,const char*image_name){
void* image;
*xsize=0;
*ysize=0;
FILE* image_file;
char*line=NULL;// pointer che conterra la matrice rappresentante l'immagine
size_t k=0,n=0;// size_t è una variabile apposita per rappresentare la size IN BYTES delle variabili
image_file=fopen(image_name,"r");
// getline(&buffer,&sizebuffer,std) assegna al buffer di size=sizebuffer quello letto nel std indicato e poi restituisce la size della riga in considerazione
for (int i=0;i<4;i++)
  k=getline( &line, &n, image_file);// skippo l'header


sscanf(line,"%d %d", ysize, xsize);// ora mi trovo nella riga contenente le dimensioni e le leggo asseegnandole alle apposite variabili
k=getline( &line, &n, image_file);//ora mi trovo nella riga contenente max_value ma non ci serve
k=getline( &line, &n, image_file);// ora mi trovo nella riga contenente i valori dei pixels
image=(void*)line;// assegna al pointer image il valore del pointer line che in questo caso sarà l'inizio della stringa contenente i valori dei pixels
fclose(image_file);
return image;
};




void* create_image(const int x_size,const int y_size,const int total_dim,const int rank)
{

void*ptr;
char *image;
int dim=x_size*y_size;
int dim_4=total_dim/4;
int quarto=total_dim/4;
image=(char*)calloc( dim, sizeof(char) );
for (int i = 0;i<x_size;i++){
    for (int j=0;j<y_size;j++){
    if((x_size*rank+i>dim_4 & x_size*rank+i<3*dim_4)&(j>quarto & j<3*quarto)){image[j+i*y_size]=(char)0;}
    else{image[j+i*y_size]=(char)255;}
    }
}



ptr=(void*)image;
return ptr;
};

void color(char* image,char* grid,int cell_size,int y_size,int row,int column){
for(int i=0;i<cell_size;i++){
    for(int j=0;j<cell_size;j++){
        image[(column*cell_size+j)+(row*cell_size+i)*cell_size*y_size]=grid[column+row*y_size];
    }
}
};


bool file_exists(const char *filename)
{
    FILE *fp = fopen(filename, "r");
    bool is_exist = false;
    if (fp != NULL)
    {
        is_exist = true;
        fclose(fp); // close the file
    }
    return is_exist;
};







#endif